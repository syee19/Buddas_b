<!DOCTYPE html>
<html lang="ko">


<head>
    <meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>0409_1</title>
	<style>

		html, body { 
			margin: 0;
			height: 100%; 
			background-color: #a4a2a3;
		}

		#c { 
			width: 100%; 
			height: 100%; 
			display: block;
			position: absolute;
			//position: fixed;
			left: 0;
			top: 0;
			//z-index: -3; //이거 활성화하면 OrbitControls가 안먹는듯? 일단 클릭으로 하는건 안됨 좌표로 되는진 모르겠음
			}

		/* web font */
		@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100;300;400;500;700;900&display=swap');
		@import url('https://fonts.googleapis.com/css2?family=Pinyon+Script&display=swap');


		/* typo graphics */
			.typo {
				z-index: 1;
				position: relative; //이거 키면 canvas의 z-index: -1 활성화 안하고도 보임
				margin-top: 2rem;
				margin-left: 2rem;
				width: 15rem;
				letter-spacing: -0.05rem;
				font-family: 'Noto Sans KR', sans-serif;
			}

				.header { margin-bottom: 6rem; }

					#title {
						font-size: 2rem;
						font-weight: 900;
						margin-bottom: 1.3rem;
					}

					#sentences {
						font-size: 1.3rem;
						font-weight: 800;
						margin-bottom: 1rem;
						line-height: 0.3;
						margin-bottom: 1rem;
					}
		

				#description {
					position: relative;
					left: 16rem;
					bottom: 14.9rem;

					font-size: 1rem;
					font-weight: 600;
					line-height: 0.3;
					color: #8a8a8a;
				}


				.makers { margin-top: 10rem; }

				#art, #tech  {
					letter-spacing: -0.05rem;
					font-family: 'Pinyon Script', cursive;
					font-size: 0.8rem;
					font-weight: 400;
					display: inline;
					margin-right: 1rem;
				}


				#lee , #choi{
					font-family: 'Noto Sans KR', sans-serif;
					font-size: 0.6rem;
					font-weight: 300;
					display: inline;
					margin-right: 3.5rem;
				}



			#date {
				width: 50rem;
				height: 4rem;

				-webkit-transform: rotate(90deg); 
    			transform: rotate(90deg);

				position: relative; 
				//z-index: -2;
				right: 6rem;
				bottom: 17rem;

				font-family: 'Pinyon Script', cursive;
				font-size: 8rem;
				font-weight: 400;
				letter-spacing: -1rem;
				color: #5b8d80;
				pointer-events: none;
			}

	</style>
</head>

<body>
	<canvas id="c"></canvas>
	<!-- text 요소 -->	
	<div class = "typo">
		<div class = "header">

			<h id = title> 석가부처님오신날 </h>
			<div id = "sentences">
				<pre>우와~   신난다 ~</pre>
				<pre>부처님~   오셨다 ~</pre>
				<pre>^ ^ ^ 석가부처님  --</pre>
				<pre>생일축카합니다 --</pre>
				<pre>미륵부처님 -- 어서오세요 --</pre>	
			</div>

		</div>

		<div id = "description">
			<pre>여기는 그냥 석가탄신일을</pre>
			<pre>축하하기 위해 만들어졌습니다</pre>
			<pre>여기 오신 모든 분들 열반하세요</pre>
		</div>
		
		<div class = "makers">
			<p id = "art" > art .  </p>
			<p id = "choi" > <a href="https://www.instagram.com/microgelo.co/">  최정화 </a> </p> 
			<p id = "tech" > tech . </p> 
			<p id = "lee" > 이신유 </p>
		</div>
	</div>

	<div id = "date">
		<p>2021  5  19</p>
	</div>
	
	<script type="module">
		import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r125/build/three.module.js';
		import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r125/examples/jsm/controls/OrbitControls.js';
		import {GLTFLoader} from 'https://threejsfundamentals.org/threejs/resources/threejs/r125/examples/jsm/loaders/GLTFLoader.js';
		import {GUI} from 'https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.module.js';
		
		function main() {
			const canvas = document.querySelector('#c');
			const renderer = new THREE.WebGLRenderer({canvas});
			
			//onDocumentMouseMove
			let mouseX = 0;
			let mouseY = 0;
			
			document.addEventListener( 'mousemove', onDocumentMouseMove );
			
			//Camera 생성
			const fov = 45;
			const aspect = 2;  // the canvas default
			const near = 0.1;
			const far = 100;
			const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
			camera.position.set(0, 10, 20);
			
			//Camera 회전 속성
			const controls = new OrbitControls(camera, canvas);
			controls.target.set(0, 5, 0); //시점 이동
			controls.update(); //이동한 시점 바라보도록 
			
			//Scene 생성
			const scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xa4a2a3 );
			
			//광원 색상 GUI
			class ColorGUIHelper {
				constructor(object, prop) {
				  this.object = object;
				  this.prop = prop;
				}
				get value() {
				  return `#${this.object[this.prop].getHexString()}`;
				}
				set value(hexString) {
				  this.object[this.prop].set(hexString);
				}
			}
			
			//광원
			{
				const skyColor = 0xB1E1FF;  // light blue
				const groundColor = 0xB97A20;  // brownish orange
				const intensity = 1;
				const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
				scene.add(light);
				
				const gui = new GUI();
				gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('skyColor');
				gui.addColor(new ColorGUIHelper(light, 'groundColor'), 'value').name('groundColor');
				gui.add(light, 'intensity', 0, 2, 0.01);
			}
			
			/*
			{
				const color = 0xFFFFFF;
				const intensity = 1;
				const light = new THREE.DirectionalLight(color, intensity);
				light.position.set(5, 10, 4);
				scene.add(light);
				scene.add(light.target); //이게 뭐지
			}
			*/
			
			//모델 크기에 맞춰 절두체 크기 재조정
			function frameArea(sizeToFitOnScreen, boxSize, boxCenter, camera) {
				const halfSizeToFitOnScreen = sizeToFitOnScreen * 0.5;
				const halfFovY = THREE.MathUtils.degToRad(camera.fov * .5);
				const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);
				// compute a unit vector that points in the direction the camera is now
				// in the xz plane from the center of the box
				const direction = (new THREE.Vector3())
					.subVectors(camera.position, boxCenter)
					.multiply(new THREE.Vector3(1, 0, 1))
					.normalize();

				// move the camera to a position distance units way from the center
				// in whatever direction the camera was from the center already
				camera.position.copy(direction.multiplyScalar(distance).add(boxCenter));

				// pick some near and far values for the frustum that
				// will contain the box.
				camera.near = boxSize / 100;
				camera.far = boxSize * 100;

				camera.updateProjectionMatrix();

				// point the camera to look at the center of the box
				camera.lookAt(boxCenter.x, boxCenter.y, boxCenter.z);
			}

			{
			const gltfLoader = new GLTFLoader();
			gltfLoader.load('./buddas.glb', (gltf) => {
				const root = gltf.scene;
				scene.add(root);

				// compute the box that contains all the stuff
				// from root and below
				const box = new THREE.Box3().setFromObject(root);
	
				const boxSize = box.getSize(new THREE.Vector3()).length();
				const boxCenter = box.getCenter(new THREE.Vector3());

				// set the camera to frame the box
				frameArea(boxSize * 0.5, boxSize, boxCenter, camera);
	
				// update the Trackball controls to handle the new size
				controls.maxDistance = boxSize * 10;
				controls.target.copy(boxCenter);
				controls.update();
				});
			}
			
			//마우스 위치에 따라 카메라 회전
			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX ) / 100;
				mouseY = ( event.clientY - windowHalfY ) / 100;

			}
			
			//canvas를 리사이징 해야하는지 검사 -> 리사이징 했으면 true 반환
			function resizeRendererToDisplaySize(renderer) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				const needResize = canvas.width !== width || canvas.height !== height;
				if (needResize) {
					renderer.setSize(width, height, false);
				}
				return needResize;
			}
			
			function render() {
				//onDocumentMouseMove
				const timer = 0.0001 * Date.now();

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;

				camera.lookAt( scene.position );
				
				//카메라의 비율을 canvas 비율로 지정
				if (resizeRendererToDisplaySize(renderer)) {
					const canvas = renderer.domElement;
					camera.aspect = canvas.clientWidth / canvas.clientHeight;
					camera.updateProjectionMatrix();
				}
				
				
				//인자로 받은 씬을 렌더링
				renderer.render(scene, camera);
				
				requestAnimationFrame(render);
			}
			requestAnimationFrame(render);
			
		}
		
		main();
	</script>
	
	
	
</body>

 

</html>
